name: Activity

on:
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:

jobs:
  metrics:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: lowlighter/metrics@latest
      with:
        user: manifoldfinance
        filename: profile/activity.svg
        token: ${{ secrets.METRICS_TOKEN }}
        base: header, activity, community, repositories, metadata
        plugin_activity: yes
        plugin_activity_limit: 5
        plugin_activity_days: 0
        plugin_activity_filter: issue, pr, release, fork, review, ref/create
        plugin_followup: yes
        plugin_followup_sections: repositories
        plugin_habits: yes
        plugin_habits_facts: yes
        plugin_habits_charts: no

name: Sync Org Labels on: push: branches: - main paths: - .github/workflows/sync-org-labels.yml - labels.json workflow_dispatch: schedule: - cron: '0 1 * * *' # At 01:00. jobs: sync-labels: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/github-script@v6 with: github-token: ${{secrets.PAT_GITHUB}} script: | // Labels to apply const labels = require(`${process.env.GITHUB_WORKSPACE}/labels.json`); // Gets current labels available on repo const currentLabels = repo => github.paginate( github.rest.issues.listLabelsForRepo, repo, response => response.data.map(label => ({ name: label.name, color: label.color, description: label.description })) ); // Syncs the config above with the target {owner, repo} const syncLabels = async repo => { const key = label => label.name.toLowerCase(); const existing = new Map(); (await currentLabels(repo)).forEach(label => existing.set(key(label), label)); const updates = labels.map(async label => { try { let label_k = key(label); let current = existing.get(label_k); existing.delete(label_k); if (current == undefined) { if (current = existing.get(label.alias)) { core.info(`Renaming ${label.alias} to ${label.name}`); return await github.rest.issues.updateLabel({ ...repo, name: label.alias, new_name: label.name, description: label.description, color: label.color }); } else { core.info(`Creating ${label.name}`); return await github.rest.issues.createLabel({...repo, ...label}); } } else if (current.color == label.color && current.description == label.description) { core.info(`Skipping ${label.name}`); } else { core.info(`Updating ${label.name}`); return await github.rest.issues.updateLabel({...repo, ...label}); } } catch (err) { core.error(`Error applying ${label.name}: ${err}`); throw err; } }); if (existing.size > 0) { const orphaned = Array.from(existing.keys()); core.warning(`Additional labels exist on ${repo.repo}: ${orphaned.join(', ')}`); } return Promise.all(updates); }; // Apply to config to all repos in the current org for await (const response of github.paginate.iterator( github.rest.repos.listForOrg, { org: context.repo.owner } )) { for (const repo of response.data) { await core.group(repo.name, () => syncLabels({ owner: repo.owner.login, repo: repo.name }).catch(core.setFailed)); }; };
